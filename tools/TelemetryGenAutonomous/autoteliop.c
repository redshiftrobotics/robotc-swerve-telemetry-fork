#pragma config(Sensor, S1,     ,               sensorI2CCustom)
#pragma config(Sensor, S2,     ,               sensorI2CCustom)
#pragma config(Sensor, S3,     ,               sensorI2CCustom)
#pragma config(Sensor, S4,     ,               sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "../../../Robotics2013-14/libraries/I2C.h"

const int DATA_ARRAY_SIZE = 5;

const int motor1EncoderData[DATA_ARRAY_SIZE] = {28, -113, -422, -743, -914};
const int motor2EncoderData[DATA_ARRAY_SIZE] = {0, 0, 0, 0, 0};
const int motor3EncoderData[DATA_ARRAY_SIZE] = {0, 0, 0, 0, 0};
const int motor4EncoderData[DATA_ARRAY_SIZE] = {0, 0, 0, 0, 0};
const int motor5EncoderData[DATA_ARRAY_SIZE] = {0, 0, 0, 0, 0};
const int motor6EncoderData[DATA_ARRAY_SIZE] = {0, 0, 0, 0, 0};

task main()
{

	for (int i = 0; i < DATA_ARRAY_SIZE-1; i++)
	{
		/*
			note: the daisychain/motor number to telemetry motor mapping is defined arbitrarily, and is
			not stored in an external data structure like the encoder counts are.
			motors map correctly due to the fact that the association is kept in sync betwen the data collection
			program and this one.
		*/
		I2C_SetEncoderPosition(S1, 1, 1, motor1EncoderData[i], 100);
		I2C_SetEncoderPosition(S1, 1, 2, motor2EncoderData[i], 100);
		I2C_SetEncoderPosition(S1, 2, 1, motor3EncoderData[i], 100);
		I2C_SetEncoderPosition(S1, 2, 2, motor4EncoderData[i], 100);
		I2C_SetEncoderPosition(S1, 3, 1, motor5EncoderData[i], 100);
		I2C_SetEncoderPosition(S1, 3, 2, motor6EncoderData[i], 100);
		// match the sampling rate of the original telemetry program
		Sleep(100);
	}

}
